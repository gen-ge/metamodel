#!/usr/bin/env python3
"""
üèóÔ∏è Context Navigator - Build Script
Gera pacotes instal√°veis do Context Navigator

üöÄ COMO USAR:

# 1. Build b√°sico (usa vers√£o padr√£o)
python3 build.py

# 2. Build com vers√£o espec√≠fica  
python3 build.py --version 2.0.0

# 3. Build com diret√≥rio fonte espec√≠fico
python3 build.py --source /caminho/para/metamodelo

# 4. Apenas limpar diret√≥rios (sem build)
python3 build.py --clean-only

# 5. Build completo com vers√£o customizada
python3 build.py --version 2.0.0-RELEASE --source .

üì¶ ARQUIVOS GERADOS (em dist/):
- context-navigator-{version}.tar.gz       # Pacote principal
- context-navigator-latest.tar.gz          # Alias para latest
- context-navigator-{version}.zip          # Pacote em formato zip
- install-context-navigator-{version}.txt  # Instalador standalone Python
- install-context-navigator-latest.txt     # Instalador standalone latest
- install-context-navigator-latest.sh      # Script shell de instala√ß√£o

üéØ FLUXO T√çPICO:
1. python3 build.py --version 2.0.0
2. cd dist/
3. # Enviar arquivos para GitHub releases
4. # Testar: tar -xzf context-navigator-2.0.0.tar.gz && cd context-navigator-2.0.0 && python3 install.py

‚öôÔ∏è OP√á√ïES:
--version, -v    : Vers√£o do build (padr√£o: 2.0.0)
--source, -s     : Diret√≥rio fonte (padr√£o: .)
--clean-only     : Apenas limpar diret√≥rios de build
--help, -h       : Mostrar ajuda
"""

import os
import sys
import shutil
import tarfile
import zipfile
import json
from pathlib import Path
from datetime import datetime
from typing import Optional
import argparse

class ContextNavigatorBuilder:
    def __init__(self, source_dir: str = ".", version: Optional[str] = None):
        """
        Inicializa o builder
        
        Args:
            source_dir: Diret√≥rio fonte do Context Navigator
            version: Vers√£o do build (se n√£o especificada, usa timestamp)
        """
        self.source_dir = Path(source_dir).resolve()
        self.src_dir = self.source_dir / "src" / "context_navigator"
        self.version = version or "2.0.0"
        self.build_dir = self.source_dir / "build"
        self.dist_dir = self.source_dir / "dist"
        
        print(f"üèóÔ∏è  Context Navigator Builder")
        print(f"üìÅ Fonte: {self.source_dir}")
        print(f"üì¶ Pacote: {self.src_dir}")
        print(f"üè∑Ô∏è  Vers√£o: {self.version}")
        print(f"üì¶ Build: {self.build_dir}")
        print(f"üì§ Distribui√ß√£o: {self.dist_dir}")
        
        # Verificar se estrutura src/ existe
        if not self.src_dir.exists():
            print(f"‚ùå Estrutura src/ n√£o encontrada em: {self.src_dir}")
            raise FileNotFoundError(f"Estrutura src/ n√£o encontrada: {self.src_dir}")
        
    def clean_build_dirs(self) -> bool:
        """Remove diret√≥rios de build e dist anteriores"""
        print(f"\nüßπ Limpando diret√≥rios de build...")
        
        try:
            if self.build_dir.exists():
                shutil.rmtree(self.build_dir)
                print(f"‚úÖ Removido: {self.build_dir}")
                
            if self.dist_dir.exists():
                shutil.rmtree(self.dist_dir)
                print(f"‚úÖ Removido: {self.dist_dir}")
                
            return True
        except Exception as e:
            print(f"‚ùå Erro ao limpar diret√≥rios: {e}")
            return False
            
    def create_build_structure(self) -> bool:
        """Cria estrutura de diret√≥rios para build"""
        print(f"\nüìÅ Criando estrutura de build...")
        
        try:
            self.build_dir.mkdir(exist_ok=True)
            self.dist_dir.mkdir(exist_ok=True)
            
            # Criar diret√≥rio do pacote
            self.package_dir = self.build_dir / f"context-navigator-{self.version}"
            self.package_dir.mkdir(exist_ok=True)
            
            print(f"‚úÖ Criado: {self.package_dir}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar estrutura: {e}")
            return False
            
    def copy_source_files(self) -> bool:
        """Copia arquivos fonte para o build"""
        print(f"\nüìã Copiando arquivos fonte...")
        
        # CORRE√á√ÉO: Criar estrutura m√≠nima sem duplica√ß√£o
        # Pacote deve conter apenas:
        # - install.py (raiz)
        # - source/ (pasta com arquivos a serem instalados)
        # - docs/ (documenta√ß√£o do projeto)
        # - README.md, etc. (arquivos informativos)
        
        try:
            # 1. Copiar install.py para a raiz do pacote
            install_source = self.src_dir / "installer" / "install.py"
            install_dest = self.package_dir / "install.py"
            
            if install_source.exists():
                shutil.copy2(install_source, install_dest)
                print(f"‚úÖ Copiado: installer/install.py -> install.py")
            else:
                print(f"‚ö†Ô∏è  install.py n√£o encontrado em: {install_source}")
                return False
            
            # 2. Criar pasta source/ com arquivos a serem instalados
            source_dest = self.package_dir / "source"
            source_dest.mkdir(exist_ok=True)
            
            # Arquivos e diret√≥rios para incluir em source/ (de src/context_navigator/)
            src_files_to_include = [
                "core/",              # ‚úÖ NOVO - M√≥dulo global (workspace_manager, daemon_manager, etc.)
                "scripts/",           # ‚úÖ Scripts globais (todos os .py)
                "templates/",         # ‚úÖ Templates para usu√°rios
                "installer/",         # ‚úÖ Sistema de instala√ß√£o global
                "context.rule",       # ‚úÖ Regras de contexto
                ".contextrc",         # ‚úÖ Configura√ß√£o (se existir)
                "__init__.py",        # ‚úÖ M√≥dulo principal
                "cn_cli_legacy.py"    # ‚úÖ CLI legado (nome correto)
            ]
            
            for item in src_files_to_include:
                source_path = self.src_dir / item
                dest_path = source_dest / item
                
                if not source_path.exists():
                    print(f"‚ö†Ô∏è  Arquivo n√£o encontrado: src/context_navigator/{item}")
                    continue
                    
                if source_path.is_dir():
                    shutil.copytree(source_path, dest_path)
                    print(f"‚úÖ Copiado: src/context_navigator/{item} -> source/{item}")
                else:
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(source_path, dest_path)
                    print(f"‚úÖ Copiado: src/context_navigator/{item} -> source/{item}")
            
            # 3. Copiar arquivos informativos do root do projeto para a raiz do pacote
            root_files_to_include = [
                "docs/",
                "examples/", 
                "README.md",               
                "LICENSE"
            ]
            
            for item in root_files_to_include:
                source_path = self.source_dir / item
                dest_path = self.package_dir / item
                
                if not source_path.exists():
                    print(f"‚ö†Ô∏è  Arquivo n√£o encontrado: {item}")
                    continue
                    
                if source_path.is_dir():
                    shutil.copytree(source_path, dest_path)
                    print(f"‚úÖ Copiado: {item}/ -> {dest_path.name}/")
                else:
                    shutil.copy2(source_path, dest_path)
                    print(f"‚úÖ Copiado: {item} -> {dest_path.name}")
                    
            return True
        except Exception as e:
            print(f"‚ùå Erro ao copiar arquivos: {e}")
            return False
            
    def create_metadata_files(self) -> bool:
        """Cria arquivos de metadados do pacote"""
        print(f"\nüìù Criando metadados do pacote...")
        
        try:
            # Criar arquivo de vers√£o
            version_info = {
                "version": self.version,
                "build_date": datetime.now().isoformat(),
                "python_min_version": "3.7",
                "dependencies": [],
                "description": "Context Navigator - Sistema de Documenta√ß√£o Context-Aware",
                "author": "Context Navigator Team",
                "license": "MIT"
            }
            
            version_file = self.package_dir / "VERSION"
            with open(version_file, 'w', encoding='utf-8') as f:
                json.dump(version_info, f, indent=2, ensure_ascii=False)
            print(f"‚úÖ Criado: VERSION")
            
            # Criar arquivo de instala√ß√£o
            install_info = {
                "install_command": "python3 install.py",
                "launcher_command": "./cn",
                "test_command": "./cn demo",
                "requirements": [
                    "Python 3.7+",
                    "Nenhuma depend√™ncia externa"
                ],
                "structure": {
                    ".context-navigator/": "Sistema instalado",
                    ".context-map/": "Dados gerados", 
                    "cn": "Launcher principal"
                }
            }
            
            install_file = self.package_dir / "INSTALL.json"
            with open(install_file, 'w', encoding='utf-8') as f:
                json.dump(install_info, f, indent=2, ensure_ascii=False)
            print(f"‚úÖ Criado: INSTALL.json")
            
            # Criar README do pacote
            readme_content = f"""# üß≠ Context Navigator v{self.version}

## üöÄ Instala√ß√£o R√°pida

### üìÅ Instala√ß√£o Local (Padr√£o)
```bash
# 1. Extrair o pacote
tar -xzf context-navigator-{self.version}.tar.gz
cd context-navigator-{self.version}

# 2. Instalar localmente
python3 install.py

# 3. Testar
python3 -m context_navigator.cn_cli demo
```

### üåê Instala√ß√£o Global (Recomendada)
```bash
# 1. Extrair o pacote
tar -xzf context-navigator-{self.version}.tar.gz
cd context-navigator-{self.version}

# 2. Instalar globalmente
python3 install.py --global

# 3. Configurar PATH (adicione ao ~/.bashrc)
export PATH="$HOME/.local/bin:$PATH"

# 4. Testar de qualquer diret√≥rio
cn demo
```

## üìã Comandos Principais

### üåê Instala√ß√£o Global
```bash
cn scan                      # Escanear documentos
cn demo                      # Demonstra√ß√£o completa
cn validate                  # Validar m√©tricas
cn new decision nome         # Criar nova decis√£o
cn help                      # Ver todos os comandos
```

### üìÅ Instala√ß√£o Local
```bash
python3 -m context_navigator.cn_cli scan
python3 -m context_navigator.cn_cli demo
python3 -m context_navigator.cn_cli validate
python3 -m context_navigator.cn_cli new decision nome
python3 -m context_navigator.cn_cli help
```

## üéØ Op√ß√µes de Instala√ß√£o

### üåê Global (Recomendada)
- **Comando**: `python3 install.py --global`
- **Localiza√ß√£o**: `~/.local/share/context-navigator/`
- **Launcher**: `~/.local/bin/cn`
- **Uso**: `cn comando` de qualquer diret√≥rio

### üìÅ Local
- **Comando**: `python3 install.py`
- **Localiza√ß√£o**: `.context-navigator/`
- **Uso**: `python3 -m context_navigator.cn_cli comando`

## üîç Busca Inteligente

O Context Navigator agora busca automaticamente por `.context-navigator/`:
- No diret√≥rio atual
- Em diret√≥rios pais
- Permite usar de subdiret√≥rios do projeto

## üéØ Sistema Instalado

- **`.context-navigator/`** - Sistema completo isolado
- **`.context-map/`** - Dados gerados pelo sistema
- **`cn`** - Launcher global (instala√ß√£o global)

## üìö Documenta√ß√£o

- `README.md` - Documenta√ß√£o completa
- `QUICK_START.md` - Guia de 15 minutos
- `INSTALL.md` - Guia de instala√ß√£o
- `docs/` - Documenta√ß√£o t√©cnica detalhada

## üîß Requisitos

- Python 3.7+
- Nenhuma depend√™ncia externa

## üéØ Transforme sua documenta√ß√£o em navega√ß√£o inteligente!
"""
            
            package_readme = self.package_dir / "README_PACKAGE.md"
            with open(package_readme, 'w', encoding='utf-8') as f:
                f.write(readme_content)
            print(f"‚úÖ Criado: README_PACKAGE.md")
            
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar metadados: {e}")
            return False
            
    def create_tarball(self) -> bool:
        """Cria arquivo .tar.gz do pacote"""
        print(f"\nüì¶ Criando arquivo .tar.gz...")
        
        try:
            # Arquivo com vers√£o espec√≠fica
            tarball_name = f"context-navigator-{self.version}.tar.gz"
            tarball_path = self.dist_dir / tarball_name
            
            with tarfile.open(tarball_path, 'w:gz') as tar:
                tar.add(self.package_dir, arcname=f"context-navigator-{self.version}")
                
            print(f"‚úÖ Criado: {tarball_path}")
            print(f"üìä Tamanho: {tarball_path.stat().st_size / 1024:.1f} KB")
            
            # Criar tamb√©m vers√£o "latest" para facilitar download
            latest_name = "context-navigator-latest.tar.gz"
            latest_path = self.dist_dir / latest_name
            
            with tarfile.open(latest_path, 'w:gz') as tar:
                tar.add(self.package_dir, arcname=f"context-navigator-{self.version}")
                
            print(f"‚úÖ Criado: {latest_path} (alias para latest)")
            print(f"üìä Tamanho: {latest_path.stat().st_size / 1024:.1f} KB")
            
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar tarball: {e}")
            return False
            
    def create_zipfile(self) -> bool:
        """Cria arquivo .zip do pacote"""
        print(f"\nüì¶ Criando arquivo .zip...")
        
        try:
            zip_name = f"context-navigator-{self.version}.zip"
            zip_path = self.dist_dir / zip_name
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
                for root, dirs, files in os.walk(self.package_dir):
                    for file in files:
                        file_path = Path(root) / file
                        arcname = file_path.relative_to(self.package_dir.parent)
                        zf.write(file_path, arcname)
                        
            print(f"‚úÖ Criado: {zip_path}")
            print(f"üìä Tamanho: {zip_path.stat().st_size / 1024:.1f} KB")
            
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar zip: {e}")
            return False
            
    def create_installer_script(self) -> bool:
        """Cria script de instala√ß√£o standalone"""
        print(f"\nüîß Criando instalador standalone...")
        
        installer_script = f"""#!/usr/bin/env python3
'''
üöÄ Context Navigator - Instalador Standalone v{self.version}
Download e instala√ß√£o autom√°tica do Context Navigator
'''

import os
import sys
import urllib.request
import tarfile
import tempfile
import shutil
from pathlib import Path

def download_and_install():
    print("üöÄ Context Navigator - Instalador Standalone v{self.version}")
    print("üì• Baixando e instalando...")
    
         # URL do pacote (sempre a vers√£o mais recente)
     package_url = "https://github.com/gen-ge/metamodel/releases/latest/download/context-navigator-latest.tar.gz"
    
    try:
        # Criar diret√≥rio tempor√°rio
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            # Baixar pacote
            print("üì• Baixando pacote...")
            package_path = temp_path / "context-navigator.tar.gz"
            urllib.request.urlretrieve(package_url, package_path)
            
            # Extrair pacote
            print("üì¶ Extraindo pacote...")
            with tarfile.open(package_path, 'r:gz') as tar:
                tar.extractall(temp_path)
                
                         # Executar instala√ß√£o
             print("‚öôÔ∏è  Instalando...")
             # Procurar diret√≥rio extra√≠do (pode ter qualquer vers√£o)
             import glob
             extracted_dirs = glob.glob(str(temp_path / "context-navigator-*"))
             if not extracted_dirs:
                 print("‚ùå Diret√≥rio extra√≠do n√£o encontrado")
                 return False
             install_dir = Path(extracted_dirs[0])
             install_script = install_dir / "install.py"
            
            if install_script.exists():
                os.system(f"cd {{install_dir}} && python3 install.py")
                print("‚úÖ Instala√ß√£o conclu√≠da!")
            else:
                print("‚ùå Script de instala√ß√£o n√£o encontrado")
                return False
                
    except Exception as e:
        print(f"‚ùå Erro na instala√ß√£o: {{e}}")
        return False
        
    return True

if __name__ == "__main__":
    if download_and_install():
        print("üéâ Context Navigator instalado com sucesso!")
        print("üí° Execute './cn help' para come√ßar")
    else:
        print("‚ùå Falha na instala√ß√£o")
        sys.exit(1)
"""
        
        try:
            # Criar instalador como .txt (GitHub n√£o bloqueia)
            standalone_path = self.dist_dir / f"install-context-navigator-{self.version}.txt"
            with open(standalone_path, 'w', encoding='utf-8') as f:
                f.write(installer_script)
                
            print(f"‚úÖ Criado: {standalone_path}")
            
            # Criar tamb√©m vers√£o "latest" para facilitar download
            latest_installer_path = self.dist_dir / "install-context-navigator-latest.txt"
            with open(latest_installer_path, 'w', encoding='utf-8') as f:
                f.write(installer_script)
                
            print(f"‚úÖ Criado: {latest_installer_path} (alias para latest)")
            
            # Criar script shell como alternativa
            shell_script = f'''#!/bin/bash
# Context Navigator - Instalador Shell v{self.version}
# Download e instala√ß√£o autom√°tica do Context Navigator

set -e  # Sair em caso de erro

echo "üöÄ Context Navigator - Instalador v{self.version}"
echo "üì• Baixando e instalando..."

# Verificar depend√™ncias
check_dependencies() {{
    echo "üîç Verificando depend√™ncias..."
    
    # Verificar Python 3
    if ! command -v python3 &> /dev/null; then
        echo "‚ùå Python 3 n√£o encontrado. Instale Python 3.7+ para continuar."
        exit 1
    fi
    
    # Verificar vers√£o do Python
    python_version=$(python3 -c "import sys; print(f'{{sys.version_info.major}}.{{sys.version_info.minor}}')")
    if ! python3 -c "import sys; sys.exit(0 if sys.version_info >= (3, 7) else 1)"; then
        echo "‚ùå Python 3.7+ requerido. Vers√£o atual: $python_version"
        exit 1
    fi
    
    # Verificar ferramenta de download
    if command -v wget &> /dev/null; then
        DOWNLOAD_CMD="wget -q"
    elif command -v curl &> /dev/null; then
        DOWNLOAD_CMD="curl -sL -o"
    else
        echo "‚ùå Nem wget nem curl encontrados. Instale uma dessas ferramentas."
        exit 1
    fi
    
    # Verificar tar
    if ! command -v tar &> /dev/null; then
        echo "‚ùå tar n√£o encontrado. Instale tar para continuar."
        exit 1
    fi
    
    echo "‚úÖ Depend√™ncias verificadas"
}}

# Fun√ß√£o de limpeza
cleanup() {{
    if [ -n "$temp_dir" ] && [ -d "$temp_dir" ]; then
        echo "üßπ Limpando diret√≥rio tempor√°rio..."
        rm -rf "$temp_dir"
    fi
}}

# Configurar trap para limpeza em caso de interrup√ß√£o
trap cleanup EXIT INT TERM

# Verificar depend√™ncias
check_dependencies

# Verificar permiss√µes no diret√≥rio atual
if [ ! -w "." ]; then
    echo "‚ùå Sem permiss√£o de escrita no diret√≥rio atual"
    exit 1
fi

# Salvar workspace original
original_dir=$(pwd)

# Criar diret√≥rio tempor√°rio
temp_dir=$(mktemp -d)
echo "üìÅ Diret√≥rio tempor√°rio: $temp_dir"
cd "$temp_dir"

# URL do pacote
PACKAGE_URL="https://github.com/gen-ge/metamodel/releases/latest/download/context-navigator-latest.tar.gz"
PACKAGE_FILE="context-navigator-latest.tar.gz"

# Baixar pacote
echo "üì• Baixando pacote..."
if command -v wget &> /dev/null; then
    wget -q "$PACKAGE_URL" -O "$PACKAGE_FILE"
else
    curl -sL "$PACKAGE_URL" -o "$PACKAGE_FILE"
fi

if [ $? -ne 0 ]; then
    echo "‚ùå Erro ao baixar pacote. Verifique sua conex√£o com a internet."
    exit 1
fi

# Verificar se o arquivo foi baixado
if [ ! -f "$PACKAGE_FILE" ]; then
    echo "‚ùå Arquivo n√£o foi baixado corretamente"
    exit 1
fi

# Extrair pacote
echo "üì¶ Extraindo pacote..."
tar -xzf "$PACKAGE_FILE"

if [ $? -ne 0 ]; then
    echo "‚ùå Erro ao extrair pacote"
    exit 1
fi

# Encontrar diret√≥rio extra√≠do
extracted_dir=$(find . -name "context-navigator-*" -type d | head -1)

if [ -z "$extracted_dir" ]; then
    echo "‚ùå Diret√≥rio extra√≠do n√£o encontrado"
    exit 1
fi

# Verificar se install.py existe
if [ ! -f "$extracted_dir/install.py" ]; then
    echo "‚ùå Script de instala√ß√£o n√£o encontrado no pacote"
    exit 1
fi

# Executar instala√ß√£o global
echo "‚öôÔ∏è  Instalando..."
cd "$extracted_dir"
python3 install.py --global

if [ $? -eq 0 ]; then
    echo "‚úÖ Instala√ß√£o global conclu√≠da!"
    echo "üí° Execute 'cn help' para come√ßar (sem ./)"
    
    # Verificar se o launcher global foi criado
    if [ -f "$HOME/.local/bin/cn" ]; then
        echo "üéØ Launcher global criado em: $HOME/.local/bin/cn"
        echo "üí° Adicione $HOME/.local/bin ao seu PATH se necess√°rio"
        echo "üí° Para usar: cn help"
    else
        echo "‚ö†Ô∏è  Launcher global n√£o encontrado. Verifique a instala√ß√£o."
        echo "üí° Verifique se ~/.local/bin/ existe e tem permiss√µes corretas"
    fi
else
    echo "‚ùå Falha na instala√ß√£o"
    exit 1
fi

# A limpeza ser√° feita automaticamente pelo trap
echo "üßπ Limpando arquivos tempor√°rios..."
'''
            
            # Criar script shell
            shell_path = self.dist_dir / "install-context-navigator-latest.sh"
            with open(shell_path, 'w', encoding='utf-8') as f:
                f.write(shell_script)
                
            # Tornar execut√°vel
            os.chmod(shell_path, 0o755)
            
            print(f"‚úÖ Criado: {shell_path} (script shell)")
            
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar instalador: {e}")
            return False
            
    def validate_build(self) -> bool:
        """Valida se o build est√° correto"""
        print(f"\nüîç Validando build...")
        
        try:
            # Verificar arquivos essenciais na raiz do pacote
            root_files = [
                "install.py",
                "README.md"
            ]
            
            for file in root_files:
                file_path = self.package_dir / file
                if not file_path.exists():
                    print(f"‚ùå Arquivo essencial n√£o encontrado: {file}")
                    return False
                print(f"‚úÖ Validado: {file}")
            
            # Verificar pasta source/ existe
            source_dir = self.package_dir / "source"
            if not source_dir.exists():
                print(f"‚ùå Pasta source/ n√£o encontrada")
                return False
            print(f"‚úÖ Validado: source/")
            
            # Verificar arquivos essenciais em source/
            source_files = [
                "scripts/core/context_scanner.py",
                "templates/decisao.md",
                "context.rule",
                ".contextrc",
                "cn_cli_legacy.py"
            ]
            
            for file in source_files:
                file_path = source_dir / file
                if not file_path.exists():
                    print(f"‚ùå Arquivo essencial n√£o encontrado: source/{file}")
                    return False
                print(f"‚úÖ Validado: source/{file}")
                
            # Verificar estrutura de diret√≥rios em source/
            source_dirs = ["scripts", "templates"]
            
            for dir_name in source_dirs:
                dir_path = source_dir / dir_name
                if not dir_path.is_dir():
                    print(f"‚ùå Diret√≥rio essencial n√£o encontrado: source/{dir_name}")
                    return False
                print(f"‚úÖ Validado: source/{dir_name}/")
                
            # Verificar estrutura de diret√≥rios na raiz
            root_dirs = ["docs", "examples"]
            
            for dir_name in root_dirs:
                dir_path = self.package_dir / dir_name
                if not dir_path.is_dir():
                    print(f"‚ùå Diret√≥rio essencial n√£o encontrado: {dir_name}")
                    return False
                print(f"‚úÖ Validado: {dir_name}/")
                
            print(f"‚úÖ Build validado com sucesso!")
            return True
        except Exception as e:
            print(f"‚ùå Erro na valida√ß√£o: {e}")
            return False
            
    def show_build_summary(self) -> None:
        """Mostra resumo do build"""
        print(f"\n" + "="*60)
        print(f"üéâ BUILD CONCLU√çDO COM SUCESSO!")
        print(f"="*60)
        print(f"")
        print(f"üì¶ Vers√£o: {self.version}")
        print(f"üìÅ Build: {self.package_dir}")
        print(f"üì§ Distribui√ß√£o: {self.dist_dir}")
        print(f"")
        print(f"üéØ ARQUIVOS GERADOS:")
        print(f"")
        
        # Listar arquivos gerados
        if self.dist_dir.exists():
            for file in self.dist_dir.iterdir():
                if file.is_file():
                    size_kb = file.stat().st_size / 1024
                    print(f"  üìÑ {file.name} ({size_kb:.1f} KB)")
                    
        print(f"")
        print(f"üöÄ PARA DISTRIBUIR:")
        print(f"")
        print(f"1. üì§ Envie arquivos para releases do GitHub")
        print(f"2. üìù Atualize URLs no instalador standalone")
        print(f"3. üß™ Teste instala√ß√£o em workspace limpo")
        print(f"")
        print(f"üéØ PARA TESTAR LOCALMENTE:")
        print(f"")
        print(f"  cd {self.dist_dir}")
        print(f"  tar -xzf context-navigator-{self.version}.tar.gz")
        print(f"  cd context-navigator-{self.version}")
        print(f"  python3 install.py")
        print(f"")
        
    def build(self) -> bool:
        """Executa build completo"""
        print(f"\nüèóÔ∏è  Iniciando build do Context Navigator...")
        
        steps = [
            ("Limpar diret√≥rios", self.clean_build_dirs),
            ("Criar estrutura", self.create_build_structure),
            ("Copiar arquivos", self.copy_source_files),
            ("Criar metadados", self.create_metadata_files),
            ("Validar build", self.validate_build),
            ("Criar tarball", self.create_tarball),
            ("Criar zip", self.create_zipfile),
            ("Criar instalador", self.create_installer_script)
        ]
        
        for step_name, step_func in steps:
            print(f"\nüìã {step_name}...")
            if not step_func():
                print(f"‚ùå Falha na etapa: {step_name}")
                return False
                
        self.show_build_summary()
        return True

def main():
    """Fun√ß√£o principal"""
    parser = argparse.ArgumentParser(description='Context Navigator Build Script')
    parser.add_argument('--version', '-v', 
                       help='Vers√£o do build (padr√£o: timestamp)')
    parser.add_argument('--source', '-s', default='.',
                       help='Diret√≥rio fonte (padr√£o: atual)')
    parser.add_argument('--clean-only', action='store_true',
                       help='Apenas limpar diret√≥rios de build')
    
    args = parser.parse_args()
    
    if args.clean_only:
        builder = ContextNavigatorBuilder(args.source)
        builder.clean_build_dirs()
        return 0
    
    builder = ContextNavigatorBuilder(args.source, args.version)
    
    if builder.build():
        print("\n‚úÖ Build conclu√≠do com sucesso!")
        return 0
    else:
        print("\n‚ùå Falha no build")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 